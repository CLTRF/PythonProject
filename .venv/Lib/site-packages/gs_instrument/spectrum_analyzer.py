import math
import os
import time
from abc import ABC, abstractmethod
import gs_instrument

from gs_instrument import InstrumentVXI11

class SpectrumAnalyzer(ABC):
    """Common interface for a spectrum analyzer instrument. This is a minimal
    set of functions available on almost any spectrum analyzer, and should not
    contain specialized modes or measurement which are only available on
    certain equipment.
    """

    @abstractmethod
    def get_id(self):
        """Get the ID of the instrument."""

    @abstractmethod
    def close(self):
        """Close the instrument."""

    @abstractmethod
    def reset(self):
        """Reset the instrument."""

    @abstractmethod
    def wait_for_operation_complete(self):
        """Wait for the most recent operation to complete."""

    @abstractmethod
    def set_cable_loss_dB(self, value):
        """Set the cable loss to compensate the power measurements with."""

    @abstractmethod
    def set_frequency_center_Hz(self, value):
        """Set the center frequency."""

    @abstractmethod
    def set_frequency_span_Hz(self, value):
        """Set the frequency span."""

    @abstractmethod
    def set_frequency_start_Hz(self, value):
        """Set the start frequency."""

    @abstractmethod
    def set_frequency_stop_Hz(self, value):
        """Set the stop frequency."""

    @abstractmethod
    def set_bandwidth_resolution_Hz(self, value):
        """Set the resolution bandwidth."""

    @abstractmethod
    def set_bandwidth_video_Hz(self, value):
        """Set the video bandwidth."""

    @abstractmethod
    def set_detector_sample(self):
        """Set the detector to sample detector."""

    @abstractmethod
    def set_detector_positive_peak(self):
        """Set the detector to positive peak."""

    @abstractmethod
    def set_detector_negative_peak(self):
        """Set the detector to negative peak."""

    @abstractmethod
    def set_detector_average(self):
        """Set the detector to average."""

    @abstractmethod
    def set_detector_rms(self):
        """Set the detector to RMS."""

    @abstractmethod
    def set_trace_max_hold(self):
        """Set the trace mode to max hold."""

    @abstractmethod
    def set_trace_clear_write(self):
        """Set the trace mode to clear/write."""

    @abstractmethod
    def set_sweep_time_s(self, value):
        """Set the sweep time."""

    @abstractmethod
    def set_sweep_points(self, value):
        """Set the number of points in a sweep."""

    @abstractmethod
    def set_marker_max(self):
        """Set the marker position to the peak."""

    @abstractmethod
    def set_marker_x(self, value):
        """Set the marker to a specific x-axis value (time [s] or frequency [Hz])."""

    @abstractmethod
    def get_marker_x(self):
        """Get the x-value (time [s] or frequency [Hz]) of the marker."""

    @abstractmethod
    def get_marker_y(self):
        """Get the y-value (power [dBm]) of the marker."""

    @abstractmethod
    def set_reference_level_dBm(self, value):
        """Set the amplitude reference level."""

    @abstractmethod
    def set_attenuation_auto(self):
        """Set the attenuator setting to auto."""

    @abstractmethod
    def set_attenuation_dB(self, value):
        """Set the attenuator setting manually - be careful!"""

    @abstractmethod
    def set_trigger_free_run(self):
        """Set the trigger mode to free-run."""

    @abstractmethod
    def set_trigger_video_dBm(self, value):
        """Set the video trigger-level (useful in zero-span)."""

    @abstractmethod
    def set_trigger_delay_s(self, value):
        """Set the trigger delay (useful in zero-span)."""

    @abstractmethod
    def set_trigger_single(self):
        """Set the trigger mode to single and re-trigger."""

    @abstractmethod
    def set_trigger_continuous(self):
        """Set the trigger mode to continuous."""

    @abstractmethod
    def get_trace_xy(self):
        """Get the trace as a list of x (time [s] or frequency [Hz]) and y
        (power [dBm]) data points, ``(x: list, y: list)``.
        """

    @abstractmethod
    def save_screenshot_png(self, filename):
        """Save a screenshot in PNG format."""

    # High-level functions, using only the abstract methods above

    def measure_channel_power_and_bandwidth(
            self, frequency_Hz, expected_bandwidth_Hz, n_percent=99, n_dB=-26,
            sweep_time_s=1.0, sweep_points=1001, frequency_span_Hz=None,
            resolution_bandwidth_Hz=None, video_bandwidth_Hz=None
        ):
        """Calculate the channel power and occupied/emission bandwidth,
        returning a dict containing the measurement parameter, bandwidth,
        and channel power is measured for three different bandwidths:

            user_bandwidth_parameter_Hz (= ``expected_bandwidth_Hz``)
            user_bandwidth_Hz
            user_bandwidth_channel_power_dBm
            occupied_bandwidth_parameter_percent (= ``n_percent``)
            occupied_bandwidth_Hz
            occupied_bandwidth_channel_power_dBm (= `n_dB`)
            emission_bandwidth_parameter_dB
            emission_bandwidth_Hz
            emission_bandwidth_channel_power_dBm

        WARNING: The following parameters will be updated:

        - Detector type = RMS
        - Trace type = clear write
        - Sweep time
        - Sweep points
        - Center frequency
        - Frequency span (None = 10 times ``expected_bandwidth_Hz``)
        - Resolution bandwidth (None = approximately 1 % of ``expected_bandwidth_Hz``)
        - Video bandwidth (None = 3 times the resolution bandwidth)
        """

        rbw = resolution_bandwidth_Hz or nearest_bandwidth_in_1_3_sequence(0.01 * expected_bandwidth_Hz)
        vbw = video_bandwidth_Hz or nearest_bandwidth_in_1_3_sequence(3 * rbw)

        self.set_detector_rms()
        self.set_trace_clear_write()
        self.set_frequency_center_Hz(frequency_Hz)
        self.set_sweep_time_s(sweep_time_s)
        self.set_sweep_points(sweep_points)
        self.set_frequency_span_Hz(frequency_span_Hz or 10*expected_bandwidth_Hz)
        self.set_bandwidth_resolution_Hz(rbw)
        self.set_bandwidth_video_Hz(vbw)

        self.set_trigger_single()
        self.wait_for_operation_complete()
        f, P = self.get_trace_xy()

        n_low_ubw, n_high_ubw = calculate_bandwidth_indexes(f, expected_bandwidth_Hz)
        n_low_obw, n_high_obw = calculate_occupied_bandwidth_indexes(P, n_percent=n_percent)
        n_low_ebw, n_high_ebw = calculate_emission_bandwidth_indexes(P, n_dB=n_dB)

        return dict(
            resolution_bandwidth_Hz=rbw,
            user_bandwidth_parameter_Hz=expected_bandwidth_Hz,
            user_bandwidth_Hz=f[n_high_ubw] - f[n_low_ubw],
            user_bandwidth_channel_power_dBm=calculate_channel_power_dBm(f[n_low_ubw:n_high_ubw], P[n_low_ubw:n_high_ubw], resolution_bandwidth_Hz=rbw),
            occupied_bandwidth_parameter_percent=n_percent,
            occupied_bandwidth_Hz=f[n_high_obw] - f[n_low_obw],
            occupied_bandwidth_channel_power_dBm=calculate_channel_power_dBm(f[n_low_obw:n_high_obw], P[n_low_obw:n_high_obw], resolution_bandwidth_Hz=rbw),
            emission_bandwidth_parameter_dB=n_dB,
            emission_bandwidth_Hz=f[n_high_ebw] - f[n_low_ebw],
            emission_bandwidth_channel_power_dBm=calculate_channel_power_dBm(f[n_low_ebw:n_high_ebw], P[n_low_ebw:n_high_ebw], resolution_bandwidth_Hz=rbw),
        )

    def measure_harmonics(
            self, frequency_Hz, max_harmonic=5, max_frequency_Hz=26.5e9,
            frequency_span_Hz=10e6, resolution_bandwidth_Hz=1e6,
            video_bandwidth_Hz=3e6, sweep_time_s=1.0, sweep_points=1001,
            detector_peak=False, detector_rms=True
        ):
        """Measure the power of the fundamental and harmonics. Returns a dict of
        the harmonics (1 = fundamental, 2 = second harmonic, etc).

        WARNING: The follwing parameters will be updated:

        - Center frequency
        - Frequency span
        - Resolution bandwidth
        - Video bandwidth
        - Detector type

        """

        if detector_peak and detector_rms:
            raise ValueError("At most one detector must be selected - not both!")

        self.set_frequency_center_Hz(frequency_Hz)
        self.set_frequency_span_Hz(frequency_span_Hz)
        self.set_bandwidth_resolution_Hz(resolution_bandwidth_Hz)
        self.set_bandwidth_video_Hz(video_bandwidth_Hz)
        self.set_sweep_time_s(sweep_time_s)
        self.set_sweep_points(sweep_points)
        if detector_peak:
            self.set_detector_positive_peak()
        elif detector_rms:
            self.set_detector_rms()

        power_dBm = dict()
        for n in range(1, max_harmonic+1, 1):
            fc = n * frequency_Hz
            if fc > max_frequency_Hz:
                continue

            self.set_frequency_center_Hz(fc)
            self.set_trigger_single()
            self.wait_for_operation_complete()
            self.set_marker_max()

            power_dBm[n] = self.get_marker_y()

        return power_dBm

class Dummy(SpectrumAnalyzer):
    """Dummy spectrum analyzer for simulation use."""

    def get_id(self):
        return "DummySpectrumAnalyzer"

    def close(self):
        pass

    def reset(self):
        pass

    def wait_for_operation_complete(self):
        pass

    def set_cable_loss_dB(self, value):
        pass

    def set_frequency_center_Hz(self, value):
        pass

    def set_frequency_span_Hz(self, value):
        pass

    def set_frequency_start_Hz(self, value):
        pass

    def set_frequency_stop_Hz(self, value):
        pass

    def set_bandwidth_resolution_Hz(self, value):
        pass

    def set_bandwidth_video_Hz(self, value):
        pass

    def set_detector_sample(self):
        pass

    def set_detector_positive_peak(self):
        pass

    def set_detector_negative_peak(self):
        pass

    def set_detector_average(self):
        pass

    def set_detector_rms(self):
        pass

    def set_trace_max_hold(self):
        pass

    def set_trace_clear_write(self):
        pass

    def set_sweep_time_s(self, value):
        pass

    def set_sweep_points(self, value):
        pass

    def set_marker_max(self):
        pass

    def set_marker_x(self, value):
        pass

    def get_marker_x(self):
        return 0

    def get_marker_y(self):
        return 0

    def set_reference_level_dBm(self, value):
        pass

    def set_attenuation_auto(self):
        pass

    def set_attenuation_dB(self, value):
        pass

    def set_trigger_free_run(self):
        pass

    def set_trigger_video_dBm(self, value):
        pass

    def set_trigger_delay_s(self, value):
        pass

    def set_trigger_single(self):
        pass

    def set_trigger_continuous(self):
        pass

    def get_trace_xy(self):
        # Triangle spectrum
        x = [X/10*1e6 for X in range(-100, 101, 1)]
        y = [-10*abs(X/1e6) for X in x]
        return x, y

    def save_screenshot_png(self, filename):
        pass

class RohdeSchwarzFSU(SpectrumAnalyzer):
    """Rohde & Schwarz FSU spectrum analyzer."""

    def __init__(self, ip_address="", reset=True, phy=None):
        self.phy = phy
        if self.phy is None:
            self.phy = InstrumentVXI11(ip_address)

        self.phy.write("SYSTEM:DISPLAY:UPDATE ON")
        if reset:
            self.reset()

    def get_id(self):
        return self.phy.query("*IDN?").strip()

    def close(self):
        self.phy.close()

    def reset(self):
        self.phy.write("*RST")

    def wait_for_operation_complete(self):
        self.phy.query("*OPC?")

    def set_cable_loss_dB(self, value):
        self.phy.write(f"DISPLAY:TRACE:Y:RLEVEL:OFFSET {value}")

    def set_frequency_center_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:CENTER {value}Hz")

    def set_frequency_span_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:SPAN {value}Hz")

    def set_frequency_start_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:START {value}Hz")

    def set_frequency_stop_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:STOP {value}Hz")

    def set_bandwidth_resolution_Hz(self, value):
        self.phy.write(f"SENSE:BANDWIDTH:RESOLUTION {value}Hz")

    def set_bandwidth_video_Hz(self, value):
        self.phy.write(f"SENSE:BANDWIDTH:VIDEO {value}Hz")

    def set_detector_sample(self):
        self.phy.write("SENSE:DETECTOR SAMPLE")

    def set_detector_positive_peak(self):
        self.phy.write("SENSE:DETECTOR POSITIVE")

    def set_detector_negative_peak(self):
        self.phy.write("SENSE:DETECTOR NEGATIVE")

    def set_detector_average(self):
        self.phy.write("SENSE:DETECTOR AVERAGE")

    def set_detector_rms(self):
        self.phy.write("SENSE:DETECTOR RMS")

    def set_trace_max_hold(self):
        self.phy.write("DISPLAY:TRACE:MODE MAXHOLD")

    def set_trace_clear_write(self):
        self.phy.write("DISPLAY:TRACE:MODE WRITE")

    def set_sweep_time_s(self, value):
        self.phy.write(f"SENSE:SWEEP:TIME {value}s")

    def set_sweep_points(self, value):
        self.phy.write(f"SENSE:SWEEP:POINTS {value}")

    def set_marker_max(self):
        self.phy.write("CALCULATE:MARKER1:MAXIMUM")

    def set_marker_x(self, value):
        self.phy.write(f"CALCULATE:MARKER1:X {value}")

    def get_marker_x(self):
        return float(self.phy.query("CALCULATE:MARKER1:X?"))

    def get_marker_y(self):
        return float(self.phy.query("CALCULATE:MARKER1:Y?"))

    def set_reference_level_dBm(self, value):
        self.phy.write(f"DISPLAY:TRACE:Y:RLEVEL {value}")

    def set_attenuation_auto(self):
        self.phy.write("INPUT:ATTENUATION:AUTO ON")

    def set_attenuation_dB(self, value):
        self.phy.write("INPUT:ATTENUATION:AUTO OFF")
        self.phy.write(f"INPUT:ATTENUATION {value}")

    def set_trigger_free_run(self):
        self.phy.write("TRIGGER:SOURCE IMMEDIATE")

    def set_trigger_video_dBm(self, value):
        top_dBm = float(self.phy.query("DISPLAY:TRACE:Y:RLEVEL?"))
        span_dB = float(self.phy.query("DISPLAY:TRACE:Y:SCALE?"))
        bottom_dBm = top_dBm - span_dB
        trigger_percent = 100 * (value - bottom_dBm)/span_dB
        self.phy.write("TRIGGER:SOURCE VIDEO")
        self.phy.write(f"TRIGGER:LEVEL:VIDEO {trigger_percent}PCT")

    def set_trigger_delay_s(self, value):
        self.phy.write(f"TRIGGER:HOLDOFF {value}")

    def set_trigger_single(self):
        self.phy.write("INITIATE:CONTINUOUS OFF")
        self.phy.write("INITIATE:IMMEDIATE")

    def set_trigger_continuous(self):
        self.phy.write("INITIATE:CONTINUOUS ON")

    def get_trace_xy(self):
        fspan = float(self.phy.query("FREQUENCY:SPAN?"))
        num_points = int(self.phy.query("SENSE:SWEEP:POINTS?"))

        if fspan == 0.0:
            tstart = 0
            tspan = float(self.phy.query("SENSE:SWEEP:TIME?"))
            dt = tspan/(num_points-1)
            x = [tstart + dt*n for n in range(num_points)]

        else:
            fstart = float(self.phy.query("SENSE:FREQUENCY:START?"))
            df = fspan/(num_points-1)
            x = [fstart + df*n for n in range(num_points)]

        self.phy.write("FORMAT REAL, 32")
        y = self.phy.query_binary_values("TRACE? TRACE1", datatype="f")
        return x, y

    def save_screenshot_png(self, filename):
        self.phy.write("MMEM:NAME 'D:\\HARDCOPY.BMP'")
        self.phy.write("HCOPY:DEST1 'MMEM'")
        self.phy.write("HCOPY:DEVICE:LANGUAGE BMP")
        self.phy.write("HCOPY:DEVICE:COLOR ON")
        self.phy.write("HCOPY:ITEM:ALL")
        self.phy.write("HCOPY:IMM1; *WAI")
        self.wait_for_operation_complete()
        data = bytearray(self.phy.query_binary_values("MMEM:DATA? 'D:\\HARDCOPY.BMP'", datatype="B"))
        self.phy.write("MMEM:DELETE 'D:\\HARDCOPY.BMP'")

        import PIL.Image
        import io

        bmp_virtual_file = io.BytesIO(data)
        image = PIL.Image.open(bmp_virtual_file)
        image.save(filename)

class KeysightCXA(SpectrumAnalyzer):
    """Keysight CXA N9000A spectrum analyzer.

    https://www.keysight.com/dk/en/assets/9018-06099/user-manuals/9018-06099.pdf
    """

    def __init__(self, ip_address="", reset=True, phy=None, auto_align=False):
        self.phy = phy
        self.auto_align = auto_align
        if self.phy is None:
            self.phy = InstrumentVXI11(ip_address)

        #if reset:
        #    self.reset()

    def get_id(self):
        return self.phy.query("*IDN?").strip()

    def close(self):
        self.phy.close()

    def reset(self):
        ### CLTself.phy.write("INSTRUMENT:SELECT SA")
        ### self.phy.write("*RST")
        if self.auto_align:
            self.phy.write("CALIBRATION:AUTO ON")
        else:
            self.phy.write("CALIBRATION:AUTO OFF")

    def wait_for_operation_complete(self):
        self.phy.query("*OPC?")

    def set_cable_loss_dB(self, value):
        # Disable any cable loss that may have been set in the VSA mode and use
        # reference level offset instead.
        self.phy.write("SENSE:CORRECTION:SA:GAIN 0")
        self.phy.write(f"DISPLAY:WINDOW:TRACE:Y:RLEVEL:OFFSET {value}")

    def set_frequency_center_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:CENTER {value}Hz")

    def set_frequency_span_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:SPAN {value}Hz")

    def set_frequency_start_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:START {value}Hz")

    def set_frequency_stop_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:STOP {value}Hz")

    def set_bandwidth_resolution_Hz(self, value):
        self.phy.write(f"SENSE:BANDWIDTH:RESOLUTION {value}Hz")

    def set_bandwidth_video_Hz(self, value):
        self.phy.write(f"SENSE:BANDWIDTH:VIDEO {value}Hz")

    def set_detector_sample(self):
        self.phy.write("SENSE:DETECTOR SAMPLE")

    def set_detector_positive_peak(self):
        self.phy.write("SENSE:DETECTOR POSITIVE")

    def set_detector_negative_peak(self):
        self.phy.write("SENSE:DETECTOR NEGATIVE")

    def set_detector_average(self):
        self.phy.write("SENSE:DETECTOR AVERAGE")

    def set_detector_rms(self):
        self.phy.write("SENSE:DETECTOR RMS")

    def set_trace_max_hold(self):
        self.phy.write("TRACE:TYPE MAXHOLD")

    def set_trace_clear_write(self):
        self.phy.write("TRACE:TYPE WRITE")

    def set_sweep_time_s(self, value):
        self.phy.write(f"SENSE:SWEEP:TIME {value}")

    def set_sweep_points(self, value):
        self.phy.write(f"SENSE:SWEEP:POINTS {value}")

    def set_marker_max(self):
        self.phy.write("CALCULATE:MARKER1:STATE ON")
        self.phy.write("CALCULATE:MARKER1:MAXIMUM")

    def set_marker_x(self, value):
        self.phy.write("CALCULATE:MARKER1:STATE ON")
        self.phy.write(f"CALCULATE:MARKER1:X {value}")

    def get_marker_x(self):
        return float(self.phy.query("CALCULATE:MARKER1:X?"))

    def get_marker_y(self):
        return float(self.phy.query("CALCULATE:MARKER1:Y?"))

    def set_reference_level_dBm(self, value):
        self.phy.write(f"DISPLAY:WINDOW:TRACE:Y:RLEVEL {value}")

    def set_attenuation_auto(self):
        self.phy.write("SENSE:POWER:ATTENUATION:AUTO ON")

    def set_attenuation_dB(self, value):
        self.phy.write("SENSE:POWER:ATTENUATION:AUTO OFF")
        self.phy.write(f"SENSE:POWER:ATTENUATION {value}")

    def set_trigger_free_run(self):
        self.phy.write("TRIGGER:SOURCE IMMEDIATE")

    def set_trigger_video_dBm(self, value):
        self.phy.write("TRIGGER:SOURCE VIDEO")
        self.phy.write(f"TRIGGER:VIDEO:LEVEL {value}dBm")

    def set_trigger_delay_s(self, value):
        self.phy.write(f"TRIGGER:VIDEO:DELAY {value}s")
        if value == 0:
            self.phy.write("TRIGGER:VIDEO:DELAY:STATE OFF")
        else:
            self.phy.write("TRIGGER:VIDEO:DELAY:STATE ON")

    def set_trigger_single(self):
        self.phy.write("INITIATE:CONTINUOUS OFF")
        self.phy.write("INITIATE:IMMEDIATE")

    def set_trigger_continuous(self):
        self.phy.write("INITIATE:CONTINUOUS ON")

    def get_trace_xy(self):
        fspan = float(self.phy.query("FREQUENCY:SPAN?"))
        num_points = int(self.phy.query("SENSE:SWEEP:POINTS?"))

        if fspan == 0.0:
            tstart = 0
            tspan = float(self.phy.query("SENSE:SWEEP:TIME?"))
            dt = tspan/(num_points-1)
            x = [tstart + dt*n for n in range(num_points)]

        else:
            fstart = float(self.phy.query("SENSE:FREQUENCY:START?"))
            df = fspan/(num_points-1)
            x = [fstart + df*n for n in range(num_points)]

        self.phy.write("FORMAT REAL,32")
        y = self.phy.query_binary_values("TRACE:DATA? TRACE1", datatype=">f")
        return x, y

    def save_screenshot_png(self, filename):
        ##self.phy.write("MMEMORY:STORE:SCREEN 'D:\\PICTURE.PNG'")
        _command_1_SCPI     =   "MMEMORY:STORE:SCREEN "+ "'" + filename + "'"
        self.phy.write(_command_1_SCPI)
        self.wait_for_operation_complete()
        _command_2_SCPI     = "MMEMORY:DATA? " + "'" + filename + "'"
        ##data = bytearray(self.phy.query_binary_values("MMEMORY:DATA? 'D:\\PICTURE.PNG'", datatype="B"))
        ### Bug data = bytearray(self.phy.query_binary_values(_command_2_SCPI, datatype="B"))
        ## self.phy.write("MMEMORY:DELETE 'D:\\PICTURE.PNG'")

        ##with open(filename, "wb") as fh:
        ##    fh.write(data)
            
    def NF_meas(self,start,stop,bw,avg,points):
        self.phy.write("*RST\n")
        sa = "INST:NSEL 219\n"
        self.phy.write(sa)
        myfreq=2000
        points_command = ":SWE:POIN {0}\n"
        self.phy.write(points_command.format(points))
        sa = ":FREQ:STAR {0}{1}\n" #video BW
        self.phy.write(sa.format(start,"MHz"))
        sa = ":FREQ:STop {0}{1}\n" #resolution BW
        self.phy.write(sa.format(stop,"MHz"))
        sa = ":BANDWIDTH {0}{1}\n" #resolution BW
        self.phy.write(sa.format(bw,"MHz"))

        avg_command = ":AVER:COUN {0}\n"
        self.phy.write(avg_command.format(avg))
        self.phy.write(":AVER ON\n")
        self.phy.write(":INIT:CONT ON\n")

    def Spurious(self,pdiv,ref,V_bw,R_bw,avg,Stop_freq,Start_freq,C_freq,points,offset,_lim): #spurious
        
        ##self.phy.write("*RST\n")
        sa = "INST:NSEL 1\n"
        self.phy.write(sa)
        sa = "INITiate:SPURious\n"
        self.phy.write(sa)

        self.phy.write(":INIT:CONT ON\n")
        #command for setting the center freq and span
        self.phy.write(":DISP:SPUR:VIEW:WIND:TRAC:Y:COUP OFF\n")
        offset_command = ":DISP:WIND:TRAC:Y:RLEV:OFFS {0:.2f} {1}\n"
        self.phy.write(offset_command.format(offset, "dB"))

        center_command = ":FREQ:CENTER {0:.2f} {1}\n"
        self.phy.write(center_command.format(C_freq, "MHz"))
        #points set up command
        sa1 = ":DISP:SPUR:VIEW:WIND:TRAC:Y:RLEV {0:.2f} dBm\n" #125" #reference level
        self.phy.write(sa1.format(ref))
        sa = ":DISP:SPUR:VIEW:WIND:TRAC:Y:PDIV {0:.2f}\n" #scale/div
        self.phy.write(sa.format(pdiv))


        #sa = ":DISP:SPUR:VIEW:WIND:TRAC:Y:PDIV {0:.2f}\n" #scale/div
        #self.phy.write(sa.format(pdiv))

        points_command = ":SWE:POIN {0}\n"
        self.phy.write(points_command.format(points))

        sa = ":SPUR:FREQ:STAR {0}{1}\n" #video BW
        self.phy.write(sa.format(Start_freq,"MHz"))
        sa = "SPUR:FREQ:STop {0}{1}\n" #resolution BW
        self.phy.write(sa.format(Stop_freq,"MHz"))

        ## self.phy.write(":INIT:CONT ON\n")

        ## self.phy.write(":CALC:MARK{:d}:STAT ON\n")
        ## self.phy.write(":CALC:SPUR:MARK1:MAX\n")
        ## yy=float(self.phy.query(":CALC:SPUR:MARK1:Y?"))
        ## print(yy)

        #if offset==1:
        #    offset_command = ":DISP:WIND:TRAC:Y:RLEV:OFFS {0:.2f} {1}\n"
        #    self.phy.write(offset_command.format(-1*yy, "dB"))


        lim =   _lim

        sa = ":CALC:SPUR:LIM:ABS:DATA:STOP {:f}\n"#{2} {3} {4} {5} {6} {7} {8}\n" #video BW
        self.phy.write(sa.format(lim))

        sa = ":SPUR:STAT {0}\n"#{2} {3} {4} {5} {6} {7} {8}\n" #video BW
        self.phy.write(sa.format("on"))

        #sa = "SPUR:BAND:VID {0} {1}" #video BW
        #self.phy.write(sa.format(V_bw,"MHz"))
        #sa = "SPUR:BAND {0:.2f} {1}" #resolution BW
        #self.phy.write(sa.format(R_bw,"MHz"))

        avg_command = "SPUR:AVER:COUN {0}\n"
        self.phy.write(avg_command.format(avg))
        self.phy.write("SPUR:AVER ON\n")

        self.phy.write(":INIT:CONT ON\n")

        #self.phy.write(":INIT:CONT OFF\n")
        #self.phy.write("*WAI\n")
        #self.phy.write(":INIT:IMM\n")
        
    def make_single_sweep(self):
        self.phy.write(":INIT:CONT OFF\n")
        self.phy.write(":INIT:IMM\n")
        self.phy.write("*OPC\n")
        self.phy.write("*WAI\n")
        #print(self.phy.query("SENS:SWE:TIME?\n")) #time of a speed
        #self.phy.write("*SRE 0 \n"")
        #self.phy.write("*CLS\n"")
    def make_cont_sweep(self):
        self.phy.write(":INIT:CONT ON\n")
        #self.phy.write(":INIT:IMM\n")
        #self.phy.write("*OPC\n")
        self.phy.write("*WAI\n")
        #print(self.phy.query("SENS:SWE:TIME?\n")) #time of a speed
        #self.phy.write("*SRE 0 \n"")
        #self.phy.write("*CLS\n"")

    def Spurious_BRO(self,pdiv,ref,V_bw,R_bw,avg,Stop_freq,Start_freq,C_freq,points,offset): #spurious
        self.phy.write("*RST\n")
        sa = "INST:NSEL 1\n"
        self.phy.write(sa)
        sa = "INITiate:SPURious\n"
        self.phy.write(sa)

        self.phy.write(":INIT:CONT ON\n")
        #command for setting the center freq and span

        #offset_command = ":DISP:WIND:TRAC:Y:RLEV:OFFS {0:.2f} {1}\n"
        #self.phy.write(offset_command.format(offset, "dB"))

        center_command = ":FREQ:CENTER {0:.2f} {1}\n"
        self.phy.write(center_command.format(C_freq, "MHz"))
        #points set up command
        sa1 = ":DISP:SPUR:VIEW:WIND:TRAC:Y:RLEV {0:.2f} dBm\n" #125" #reference level
        self.phy.write(sa1.format(ref))

        sa = ":DISP:SPUR:VIEW:WIND:TRAC:Y:PDIV {0:.2f} dB\n" #scale/div
        self.phy.write(sa.format(pdiv))

        points_command = ":SWE:POIN {0}\n"
        self.phy.write(points_command.format(points))

        sa = ":SPUR:FREQ:STAR {0}{1}\n" #video BW
        self.phy.write(sa.format(Start_freq,"MHz"))
        sa = "SPUR:FREQ:STop {0}{1}\n" #resolution BW
        self.phy.write(sa.format(Stop_freq,"MHz"))
        #sa = ":CALC:SPUR:LIM:ABS:DATA:STOP {:f}\n"#{2} {3} {4} {5} {6} {7} {8}\n" #video BW
        #self.phy.write(sa.format(lim))


        sa = ":SPUR:STAT {0}\n"#{2} {3} {4} {5} {6} {7} {8}\n" #video BW
        self.phy.write(sa.format("on"))


        #sa = "SPUR:BAND:VID {0} {1}" #video BW
        #self.phy.write(sa.format(V_bw,"MHz"))
        #sa = "SPUR:BAND {0:.2f} {1}" #resolution BW
        #self.phy.write(sa.format(R_bw,"MHz"))

        avg_command = "SPUR:AVER:COUN {0}\n"
        self.phy.write(avg_command.format(avg))
        self.phy.write("SPUR:AVER ON\n")
        self.make_single_sweep()

        #self.phy.write(":INIT:CONT OFF\n")
        #self.phy.write("*WAI\n")
        #self.phy.write(":INIT:IMM\n")

    def spur_subband_BRO(self,offset):
        lim=-50
        self.phy.write(":INIT:CONT ON\n")
        offset_command = "DISP:WIND:TRAC:Y:RLEV:OFFS {0:.2f} {1}\n"
        self.phy.write(offset_command.format(offset, "dB"))
        sa = "CALC:SPUR:LIM:ABS:DATA:STOP {:f},{:f},{:f},{:f},{:f},{:f},{:f},{:f},{:f},{:f}\n"#{2} {3} {4} {5} {6} {7} {8}\n" #video BW
        self.phy.write(sa.format(lim,lim,lim,lim,lim,lim,lim,lim,lim,lim))

        sa = ":SPUR:STAT {0},{1},{2},{3},{4},{5},{6},{7},{8},{9}\n"#{2} {3} {4} {5} {6} {7} {8}\n" #video BW
        self.phy.write(sa.format("on","on","on","on","on","on","on","on","on","on"))
        sa = "SPUR:FREQ:STAR {0}MHz,{1}MHz,{2}MHz,{3}MHz,{4}MHz,{5}MHz,{6}MHz,{7}MHz,{8}MHz,{9}MHz\n" #video BW
        self.phy.write(sa.format(1000,3000,3900,4900,5900,6900,10800,15400,17500,18200))
        sa = "SPUR:FREQ:STop {0}MHz,{1}MHz,{2}MHz,{3}MHz,{4}MHz,{5}MHz,{6}MHz,{7}MHz,{8}MHz,{9}MHz\n" #video BW
        self.phy.write(sa.format(3000,3900,4900,5900,6900,10800,15400,17500,18200,26000))
        points=1001
        sa = "SPUR:SWE:POIN {0},{1},{2},{3},{4},{5},{6},{7},{8},{9}\n" #video BW
        self.phy.write(sa.format(points,points,points,points,points,points,points,points,points,points))

        RES_BW=100000
        #RES_BW1=10000
        sa = "SPUR:band {0}Hz,{1}Hz,{2}Hz,{3}Hz,{4}Hz,{5}Hz,{6}Hz,{7}Hz,{8}Hz,{9}Hz\n" #video BW
        self.phy.write(sa.format(RES_BW,RES_BW,RES_BW,RES_BW,RES_BW,RES_BW,RES_BW,RES_BW,RES_BW,RES_BW))
        #self.phy.write("*WAI\n")
        self.phy.write("SPUR:SPUR 1\n") #dirty code

    def get_NF(self):
        points_query = ":FETCh:CORR:NFIG?"
        xx=self.phy.query(points_query)
        xx=self.phy.query(points_query)
        print(xx)
        if len(xx)>0:
            self.NF=[float(x) for x in xx.split(',')]
        points_query = ":FETCh:CORR:GAIN?"
        xx=self.phy.query(points_query)
        xx=self.phy.query(points_query)
        if len(xx)>0:
            self.Gain=[float(x) for x in xx.split(',')]
        return self.NF, self.Gain #return in MHz
    
    def copy_picture1(self,filname):
        time.sleep(2)
        self.phy.write("MMEM:STOR:SCR:THEM TDC") #FCOL

        xx1=":MMEM:STOR:SCR C:\Temp\{0}.png"
        ####  sandbox CLT xx1 = ":MMEM:STOR:SCR C:\Temp\stash.png"
        #print("fil:",xx1.format(filname))
        self.phy.write(xx1.format(filname))
        self.phy.write("*OPn")

####xx2="MMEM:DATA? \"C:\Temp\{0}.png"

        xx2 = "MMEM:DATA? C:\Temp\{0}.png"
        xx2 = "MMEM:DATA? C:\Temp\stash.png"
        self.phy.write(xx2.format(filname))
        # instead of binblockread()
        capture = self.phy.query_binary_values(1,"B") #":MMEM:DATA? \"c:\Temp\pic1.png\"\n")#, datatype='c',is_big_endian=True) #,container=list)#,
        print('file: {0}.png'.format(filname))
        ###  sandbox CLT  print('file: stash.png'.format(filname))
        #with open('pic4.png', 'wb') as fp:
        ### sandbox CLT with open('stash.png'.format(filname), 'wb') as fp:
        with open('{0}.png'.format(filname), 'wb') as fp:
            for byte in capture:
             fp.write(byte)
        fp.close()
        #print(len(capture))
        #print(capture)
        self.phy.query("*CLS")

        ##self.phy.write(":MMEM:DEL C:\Temp\{0}.png".format(filname))
        self.phy.write(":MMEM:DEL C:\Temp\stash.png".format(filname))

    def set_up_EMC_EMI(self, frequency_start_Hz, frequency_stop_Hz, rbw, type_of_detector, polarity):

        myfile = (f"spec{time.strftime('%Y-%m-%d_%H%M%S')}")
        csv_myfile = myfile + ".csv"
        png_myfile = myfile + ".png"
        output = gs_instrument.CsvWriter(csv_myfile)
        # sa =gs_instrument.spectrum_analyzer
        self.reset()  # reset spectrum analyzer
        self.set_frequency_start_Hz(frequency_start_Hz)  # set frequency
        self.set_frequency_stop_Hz(frequency_stop_Hz)

        # sa.set_sweep_time_s(sweep_time_s) #set time to record
        # SA.set_frequency_span_Hz(frequency_span_Hz) #set span bandwidth
        self.set_bandwidth_resolution_Hz(rbw)  # set rbw
        self.set_detector_positive_peak()
        self.set_attenuation_dB(0)
        #    SA.phy.write(f"AVER:COUN {int(avg_count)}")

        # sa.set_attenuation_auto()
        self.set_trigger_continuous()
        # sa.set_reference_level_dBm(plevel) #set power ref level
        # sa.set_trace_max_hold() #set max hold
        # sa.set_bandwidth_video_Hz(rbw) #set vbw
        # sa.set_sweep_points(sweep_points) #set number of points


class KeysightEXA(KeysightCXA):
    """Keysight EXA N9010B spectrum analyzer.

    The X-series spectrum analyzers use (mostly) the same commands set. Most of
    this class is therefore inherited from the KeysightCXA.
    """
    pass

class TektronixRSA306B(SpectrumAnalyzer):
    """Tektronix RSA306B USB spectrum analyzer through the SignalVu software
    acting as a local VXI-11 server.
    """

    def __init__(self, ip_address="", reset=True, phy=None):
        self.phy = phy
        if self.phy is None:
            self.phy = InstrumentVXI11(ip_address)

        if reset:
            self.reset()

    def get_id(self):
        return self.phy.query("*IDN?").strip()

    def close(self):
        self.phy.close()

    def reset(self):
        self.phy.write("*RST")

    def wait_for_operation_complete(self):
        self.phy.query("*OPC?")

    def set_cable_loss_dB(self, value):
        self.phy.write(f"CALIBRATION:CORRECTION:EXTERNAL:GAIN {-value}")
        self.phy.write("CALIBRATION:CORRECTION:EXTERNAL:GAIN:STATE ON")

    def set_frequency_center_Hz(self, value):
        self.phy.write(f"SENSE:SPECTRUM:FREQUENCY:CENTER {value}")

    def set_frequency_span_Hz(self, value):
        if value == 0:
            raise ValueError("Zero-span measurements not currently supported.")
        self.phy.write(f"SENSE:SPECTRUM:FREQUENCY:SPAN {value}")

    def set_frequency_start_Hz(self, value):
        self.phy.write(f"SENSE:SPECTRUM:FREQUENCY:START {value}")

    def set_frequency_stop_Hz(self, value):
        self.phy.write(f"SENSE:SPECTRUM:FREQUENCY:STOP {value}")

    def set_bandwidth_resolution_Hz(self, value):
        self.phy.write(f"SENSE:SPECTRUM:BANDWIDTH:RESOLUTION {value}")

    def set_bandwidth_video_Hz(self, value):
        self.phy.write(f"SENSE:SPECTRUM:BANDWIDTH:VIDEO {value}")
        self.phy.write("SENSE:SPECTRUM:BANDWIDTH:VIDEO:STATE ON")

    def set_detector_sample(self):
        self.phy.write("TRACE1:SPECTRUM:DETECTION SAMPLE")

    def set_detector_positive_peak(self):
        self.phy.write("TRACE1:SPECTRUM:DETECTION POSITIVE")

    def set_detector_negative_peak(self):
        self.phy.write("TRACE1:SPECTRUM:DETECTION NEGATIVE")

    def set_detector_average(self):
        self.phy.write("TRACE1:SPECTRUM:DETECTION AVGLOG")

    def set_detector_rms(self):
        self.phy.write("TRACE1:SPECTRUM:DETECTION AVERAGE")

    def set_trace_max_hold(self):
        self.phy.write("TRACE1:SPECTRUM:FUNCTION MAXHOLD")

    def set_trace_clear_write(self):
        self.phy.write("TRACE1:SPECTRUM:FUNCTION NONE")

    def set_sweep_time_s(self, value):
        raise NotImplementedError("No sweep time option available for this instrument.")

    def set_sweep_points(self, value):
        """Only discrete settings are available. Selecting the first available
        setting larger than the requested setting.
        """
        options = [801, 2401, 4001, 8001, 10401, 16001, 32001, 64001]
        for option in options:
            if option >= value:
                self.phy.write(f"SENSE:SPECTRUM:POINTS:COUNT P{option:d}")
                return
        raise ValueError(f"Unable to set the number of sweep points to {value}")

    def set_marker_max(self):
        self.phy.write("CALCULATE:MARKER:AOFF")
        self.phy.write("CALCULATE:MARKER:ADD")
        self.phy.write("CALCULATE:SPECTRUM:MARKER0:MAXIMUM")

    def set_marker_x(self, value):
        self.phy.write("CALCULATE:MARKER:AOFF")
        self.phy.write("CALCULATE:MARKER:ADD")
        self.phy.write(f"CALCULATE:SPECTRUM:MARKER0:X {value}")

    def get_marker_x(self):
        return float(self.phy.query("CALCULATE:SPECTRUM:MARKER0:X?"))

    def get_marker_y(self):
        return float(self.phy.query("CALCULATE:SPECTRUM:MARKER0:Y?"))

    def set_reference_level_dBm(self, value):
        self.phy.write(f"INPUT:RLEVEL {value}")

    def set_attenuation_auto(self):
        self.phy.write("INPUT:ATTENUATION:AUTO ON")

    def set_attenuation_dB(self, value):
        self.phy.write("INPUT:ATTENUATION:AUTO OFF")
        self.phy.write(f"INPUT:ATTENUATION {value}")

    def set_trigger_free_run(self):
        raise NotImplementedError("Triggering/zero-span not currently implemented.")

    def set_trigger_video_dBm(self, value):
        raise NotImplementedError("Triggering/zero-span not currently implemented.")

    def set_trigger_delay_s(self, value):
        raise NotImplementedError("Triggering/zero-span not currently implemented.")

    def set_trigger_single(self):
        self.phy.write("INITIATE:CONTINUOUS OFF")
        self.phy.write("INITIATE:IMMEDIATE")

    def set_trigger_continuous(self):
        self.phy.write("INITIATE:CONTINUOUS ON")

    def get_trace_xy(self):
        fspan = float(self.phy.query("SENSE:SPECTRUM:FREQUENCY:SPAN?"))
        num_points = int(self.phy.query("SENSE:SPECTRUM:POINTS:COUNT?")[1:])

        if fspan == 0.0:
            raise NotImplementedError("Zero-span not currently implemented.")
        else:
            fstart = float(self.phy.query("SENSE:SPECTRUM:FREQUENCY:START?"))
            df = fspan/(num_points-1)
            x = [fstart + df*n for n in range(num_points)]

        y = self.phy.query_binary_values("FETCH:SPECTRUM:TRACE1?", datatype="f")
        return x, y

    def save_screenshot_png(self, filename):
        if os.path.isabs(filename):
            full_filename = filename
        else:
            here = os.path.abspath(".")
            full_filename = os.path.join(here, filename)
        self.phy.write(f'MMEMORY:STORE:SCREEN "{full_filename}"')

class RigolDSA832E(SpectrumAnalyzer):
    """Rigol DSA832E spectrum analyzer."""

    def __init__(self, ip_address="", reset=True, phy=None):
        self.phy = phy
        if self.phy is None:
            self.phy = InstrumentVXI11(ip_address)

        if reset:
            self.reset()

    def get_id(self):
        return self.phy.query("*IDN?").strip()

    def close(self):
        self.phy.close()

    def reset(self):
        self.phy.write("*RST")

    def wait_for_operation_complete(self):
        self.phy.query("*OPC?")

    def set_cable_loss_dB(self, value):
        self.phy.write(f"DISPLAY:WINDOW:TRACE:Y:RLEVEL:OFFSET {value}")

    def set_frequency_center_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:CENTER {value}")

    def set_frequency_span_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:SPAN {value}")

    def set_frequency_start_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:START {value}")

    def set_frequency_stop_Hz(self, value):
        self.phy.write(f"SENSE:FREQUENCY:STOP {value}")

    def set_bandwidth_resolution_Hz(self, value):
        self.phy.write(f"SENSE:BANDWIDTH:RESOLUTION {value}")

    def set_bandwidth_video_Hz(self, value):
        self.phy.write(f"SENSE:BANDWIDTH:VIDEO {value}")

    def set_detector_sample(self):
        self.phy.write("SENSE:DETECTOR SAMPLE")

    def set_detector_positive_peak(self):
        self.phy.write("SENSE:DETECTOR POSITIVE")

    def set_detector_negative_peak(self):
        self.phy.write("SENSE:DETECTOR NEGATIVE")

    def set_detector_average(self):
        self.phy.write("SENSE:DETECTOR VAVERAGE")

    def set_detector_rms(self):
        self.phy.write("SENSE:DETECTOR RMS")

    def set_trace_max_hold(self):
        self.phy.write("TRACE1:MODE MAXHOLD")

    def set_trace_clear_write(self):
        self.phy.write("TRACE1:MODE WRITE")

    def set_sweep_time_s(self, value):
        self.phy.write(f"SENSE:SWEEP:TIME {value}")

    def set_sweep_points(self, value):
        self.phy.write(f"SENSE:SWEEP:POINTS {value}")

    def set_marker_max(self):
        self.phy.write("CALCULATE:MARKER1:MAXIMUM:MAX")

    def set_marker_x(self, value):
        self.phy.write(f"CALCULATE:MARKER1:X {value}")

    def get_marker_x(self):
        return float(self.phy.query("CALCULATE:MARKER1:X?"))

    def get_marker_y(self):
        return float(self.phy.query("CALCULATE:MARKER1:Y?"))

    def set_reference_level_dBm(self, value):
        self.phy.write(f"DISPLAY:WINDOW:TRACE:Y:RLEVEL {value}")

    def set_attenuation_auto(self):
        self.phy.write("SENSE:POWER:ATTENUATION:AUTO ON")

    def set_attenuation_dB(self, value):
        self.phy.write("SENSE:POWER:ATTENUATION:AUTO OFF")
        self.phy.write(f"SENSE:POWER:ATTENUATION {value}")

    def set_trigger_free_run(self):
        self.phy.write("TRIGGER:SEQUENCE:SOURCE IMMEDIATE")

    def set_trigger_video_dBm(self, value):
        self.phy.write("TRIGGER:SEQUENCE:SOURCE VIDEO")
        self.phy.write(f"TRIGGER:SEQUENCE:VIDEO:LEVEL {value}")

    def set_trigger_delay_s(self, value):
        raise NotImplementedError("Trigger delay not available on the Rigol DSA832E")

    def set_trigger_single(self):
        # This command is not too stable on the Rigol, so a a few tries are
        # sometimes required
        for _ in range(10):
            try:
                self.phy.write("INITIATE:CONTINUOUS OFF")
                self.phy.write("INITIATE:IMMEDIATE")
                self.wait_for_operation_complete()
                return
            except Exception:
                pass
        raise TimeoutError("Failed to execute single-trigger command")

    def set_trigger_continuous(self):
        self.phy.write("INITIATE:CONTINUOUS ON")

    def get_trace_xy(self):
        fspan = float(self.phy.query("FREQUENCY:SPAN?"))
        num_points = int(self.phy.query("SENSE:SWEEP:POINTS?"))

        if fspan == 0.0:
            tstart = 0
            tspan = float(self.phy.query("SENSE:SWEEP:TIME?"))
            dt = tspan/(num_points-1)
            x = [tstart + dt*n for n in range(num_points)]

        else:
            fstart = float(self.phy.query("SENSE:FREQUENCY:START?"))
            df = fspan/(num_points-1)
            x = [fstart + df*n for n in range(num_points)]

        self.phy.write("FORMAT:TRACE:DATA REAL,32")
        y = self.phy.query_binary_values("TRACE:DATA? TRACE1", datatype="f")
        return x, y

    def save_screenshot_png(self, filename):
        data = bytearray(self.phy.query_binary_values("PRIVATE:SNAP? BMP", datatype="B"))

        import PIL.Image
        import io

        bmp_virtual_file = io.BytesIO(data)
        image = PIL.Image.open(bmp_virtual_file)
        image.save(filename)

#
# Utility functions
#

def nearest_bandwidth_in_1_3_sequence(target_Hz):
    """Find the nearest bandwidth setting in the 1-3 sequence (10 kHz, 30 kHz, etc)."""

    sequence_Hz = [
        1, 3, 10, 30, 100, 300, 1000, 3000, 10e3, 30e3,
        100e3, 300e3, 1e6, 3e6, 10e6, 30e6, 100e6, 300e6,
    ]
    idx = min(range(len(sequence_Hz)), key=lambda i: abs(sequence_Hz[i] - target_Hz))
    return sequence_Hz[idx]

def calculate_bandwidth_indexes(frequency_trace_Hz, bandwidth_Hz):
    """Calculate the indexes of the edge of the given bandwidth."""

    n_mid = len(frequency_trace_Hz)//2

    for n in reversed(range(0, n_mid)):
        n_low = n
        if frequency_trace_Hz[n] < frequency_trace_Hz[n_mid] - bandwidth_Hz/2:
            break
    else:
        raise IndexError("Failed fo find lower band edge")

    for n in range(n_mid, len(frequency_trace_Hz) + 1):
        n_high = n
        if frequency_trace_Hz[n] > frequency_trace_Hz[n_mid] + bandwidth_Hz/2:
            break
    else:
        raise IndexError("Failed fo find upper band edge")

    return n_low, n_high

def calculate_occupied_bandwidth_indexes(power_trace_dBm, n_percent=99):
    """Calculate the indexes where a given percentage of power is contained within.

    Reference:
    - Signal Hound - Occupied Bandwidth and Channel Power Measurements with a Real-time Spectrum Analyzer
      https://silvertoneelectronics.com/wp-content/uploads/2020/09/Occupied-Bandwidth-and-Channel-Power-Measurements-with-a-Real-time-Spectrum-Analyzer.pdf
    """

    P = [10**(X/10) for X in power_trace_dBm]
    P_total = sum(P)

    P_threshold = (1 - n_percent/100)/2 * P_total

    P_acc = 0
    for n in range(len(P)):
        n_low = n
        P_acc += P[n]
        if P_acc > P_threshold:
            break
    else:
        raise IndexError("Failed fo find lower band edge")

    P_acc = 0
    for n in reversed(range(len(P))):
        n_high = n
        P_acc += P[n]
        if P_acc > P_threshold:
            break
    else:
        raise IndexError("Failed fo find upper band edge")

    return n_low, n_high

def calculate_emission_bandwidth_indexes(power_trace_dBm, n_dB=-26, reference="max"):
    """Calculate the indexes where the power has dropped to N dB from the reference point.

    Reference:

    - "max" = Use trace maximum as reference
    - "center" = Use trace center point as reference
    - (int) = Use ``power_trace_dBm[reference]`` as a reference
    """

    P = power_trace_dBm

    if reference == "max":
        P_max = -math.inf
        for n in range(len(P)):
            if P[n] > P_max:
                n_max = n
                P_max = P[n]
    elif reference == "center":
        n_max = len(P)//2
    else:
        n_max = int(reference)

    n_low = 0
    for n in range(0, n_max):
        if P[n] > P[n_max] + n_dB:
            break
        n_low = n
    else:
        n_low = 0

    n_high = len(P) - 1
    for n in reversed(range(n_max, len(P))):
        if P[n] > P[n_max] + n_dB:
            break
        n_high = n
    else:
        n_high = len(P) - 1

    return n_low, n_high

def calculate_power_spectral_density_dBm_Hz(power_trace_dBm, resolution_bandwidth_Hz, equivalent_noise_bandwidth_factor=1.056):
    """Convert the measured power spectrum to a power spectral density spectrum in dBm/Hz.

    References:

    - Keysight - Spectrum and Signal Analyzer Measurements and Noise (Application Note)
        https://www.keysight.com/dk/en/assets/7018-06765/application-notes/5966-4008.pdf
    """

    enbw = resolution_bandwidth_Hz * equivalent_noise_bandwidth_factor
    psd_trace_dBm_Hz = [10*math.log10((10**(X/10))/enbw) for X in power_trace_dBm]
    return psd_trace_dBm_Hz

def calculate_channel_power_dBm(frequency_trace_Hz, power_trace_dBm, resolution_bandwidth_Hz, equivalent_noise_bandwidth_factor=1.056):
    """Calculate the channel power of a spectrum. Please crop the trace to the
    bandwidth of interest before using this function!

    References:

    - Keysight - Spectrum and Signal Analyzer Measurements and Noise (Application Note)
        https://www.keysight.com/dk/en/assets/7018-06765/application-notes/5966-4008.pdf
    - Rohde & Schwarz - Fundamentals of Spectrum Analysis (Rauscher)
    """

    N = len(frequency_trace_Hz)
    p = sum([10**(X/10) for X in power_trace_dBm])

    Bs = frequency_trace_Hz[-1] - frequency_trace_Hz[0]
    Bn = resolution_bandwidth_Hz * equivalent_noise_bandwidth_factor

    Pch = Bs/Bn * (p/N)
    return 10*math.log10(Pch)
